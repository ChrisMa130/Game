2016年5月7日 00:36:32
通过阅读文档，可以分析出游戏中多个对象，比如角色（主角和NPC），道具以及线段等。还有一些游戏机制，比如画线，碰撞检测，通关以及死亡等。
如果按照以往的，面向对象的游戏设计思路，那么依据分类就可以来实现了，不过现在需求还不是很明确，不好下手。
另外一个思路，按照面向组件的开发思路来设计，那么这个就比较考验抽象能力。Unity就是一个很好的面向组件的工程。
比如，要定义什么是组件？移动，是一个组件，但凡挂载了移动组件的Object，都具备移动属性（但缺少Input行为，所以无法真正移动）。
那么光有组件还不够，还要定义行为，比如接受输入、碰撞等。这里有一个难点，就是行为和组件之间的关联，Unity各个组件之间大多是没什么关联的，在新的UI组件中，使用了事件机制来做关联，那么问题来了，这个产品是否使用这么复杂的设计呢？
组件设计的好处：通过组合的形式来拼接成为一个产品，各个组件之间使用消息来做关联，组件相对独立，减少耦合，在需要重复修改的产品开发中有较大的优势。
组件设计的缺点：复杂，组件和行为的定义需要多年的程序设计经验，定义不合理不清晰，就会增加后期开发难度，开发难度的增加，开发周期上也会随之增加。

面向对象的好处：传统开发思路，易于理解，快速原型开发，各司其职。
面向对象的害处：虽可通过设计来解决部分耦合，但后期修改时，很难避免部分模块重构。（唉，，技能这都是第三版了。泪目）

还有面向关卡的设计，这个适合原型，或者小产品开发，稍微上点规模或者希望灵活配置的产品就无法胜任。（如果有强力设计能力也可以做，不过个人感觉做到最后还是成了组件）。

不过目前文档尚未完善，很多细节部分无法确定，此时不易动手，而是细化需求，理解需求，然后再思考和设计，最后动手。争取一次搞定一版。（策划需求修改是无法避免的）

2016年5月9日 00:37:39
经过思考，决定使用传统的开发模式，为什么？组件耗时可能会比较长，后期添加的需求很难避免会对前面功能造成比较大的冲击（考虑实际策划水平），开发人员能力不是同一个水平线，很难保证代码质量，返工修改代码，会对进度造成影响。最后组件理解起来有点困难，其他开发接手难度大。基于以上思考，还是选用传统比较稳妥。
定好框架结构后就开始思考细节部分。
配置问题：这个游戏是否需要配置？基于关卡的开发，实际上并不需要配置，所以暂时忽略这个模块。
控制：不是网络游戏，刚体，物理引擎什么的都可以上。
表现：角色表现不区分表现逻辑和表现层，因为没必要呀。。又不是ACT游戏。。
关卡实现：大量的，细小的组件脚本来组成关卡逻辑（不是网络游戏的优势哇。。。）
时间控制：
	暂停：好说，但思考下不用Timescale，冥冥之中感觉这是一个坑。
	时间倒退：如果是坐标等非表现类倒退，好说，但如果涉及到了表现，就可能需要快照功能，目前文档这块细节需要补充。
	时间快进：倒退后，在快进，同理倒退。
线段：逻辑好实现，但这有个坑，线段在产生之后，是会影响到可能被影响到的对象的轨迹（或者逻辑内容），比如时间倒退时，在屁股后面花一个线，那么主角实际上是会被线段挡住无法后退，所以这个坑就是对时间控制的影响，这里有一些细节需要补充，比如回退时是否还记录快照？倒退被挡住后，在快进，被线段影响的对象，是如何按照快照的轨迹快进的。

剩下就是一次关卡脚本，没什么可以啰嗦的了。
嗯。为何一个09年的游戏有还要48块。。。。Orz

2016年5月10日 01:26:57
昨天想的是，表现和逻辑不区分，不过这样就又耦合了，初步想法使用interface来拆分，不过这样的话Player类就不能叫这个名字，这个类的功能是针对主角的，但中间又夹杂着表现和移动逻辑的interface，怎么看都是别扭的。
想法其实很简单，希望一个基于接口的对象类，可以操作游戏内所有对象，只是针对不同的对象，挂接不同的实现而已，但是否需要这么灵活的设定，需要再想想，就酱~~

2016年5月12日 02:15:40
昨天体检要早睡，今天玩了几个小时Braid，好吧，好难。。。前进和后腿还有进度的，表现力也很强，各种材质满天飞。。美术赞~

2016年5月14日01:39:24
移动问题解决了，旧跳跃代码存在bug，可能会跳的非常高，新的实现需要修改地图layer，现在没鼠标调整起来好麻烦，明天搞个鼠标来调。
其实我更喜欢自己算跳跃，这样跳多高，多远，多少时间都是可控制的，用物理引擎就只能发呆。。另外，2D判断是否落地的方法还有很多种，比如碰撞、距离等等。