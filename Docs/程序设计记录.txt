2016年5月7日 00:36:32
通过阅读文档，可以分析出游戏中多个对象，比如角色（主角和NPC），道具以及线段等。还有一些游戏机制，比如画线，碰撞检测，通关以及死亡等。
如果按照以往的，面向对象的游戏设计思路，那么依据分类就可以来实现了，不过现在需求还不是很明确，不好下手。
另外一个思路，按照面向组件的开发思路来设计，那么这个就比较考验抽象能力。Unity就是一个很好的面向组件的工程。
比如，要定义什么是组件？移动，是一个组件，但凡挂载了移动组件的Object，都具备移动属性（但缺少Input行为，所以无法真正移动）。
那么光有组件还不够，还要定义行为，比如接受输入、碰撞等。这里有一个难点，就是行为和组件之间的关联，Unity各个组件之间大多是没什么关联的，在新的UI组件中，使用了事件机制来做关联，那么问题来了，这个产品是否使用这么复杂的设计呢？
组件设计的好处：通过组合的形式来拼接成为一个产品，各个组件之间使用消息来做关联，组件相对独立，减少耦合，在需要重复修改的产品开发中有较大的优势。
组件设计的缺点：复杂，组件和行为的定义需要多年的程序设计经验，定义不合理不清晰，就会增加后期开发难度，开发难度的增加，开发周期上也会随之增加。

面向对象的好处：传统开发思路，易于理解，快速原型开发，各司其职。
面向对象的害处：虽可通过设计来解决部分耦合，但后期修改时，很难避免部分模块重构。（唉，，技能这都是第三版了。泪目）

还有面向关卡的设计，这个适合原型，或者小产品开发，稍微上点规模或者希望灵活配置的产品就无法胜任。（如果有强力设计能力也可以做，不过个人感觉做到最后还是成了组件）。

不过目前文档尚未完善，很多细节部分无法确定，此时不易动手，而是细化需求，理解需求，然后再思考和设计，最后动手。争取一次搞定一版。（策划需求修改是无法避免的）

2016年5月9日 00:37:39
经过思考，决定使用传统的开发模式，为什么？组件耗时可能会比较长，后期添加的需求很难避免会对前面功能造成比较大的冲击（考虑实际策划水平），开发人员能力不是同一个水平线，很难保证代码质量，返工修改代码，会对进度造成影响。最后组件理解起来有点困难，其他开发接手难度大。基于以上思考，还是选用传统比较稳妥。
定好框架结构后就开始思考细节部分。
配置问题：这个游戏是否需要配置？基于关卡的开发，实际上并不需要配置，所以暂时忽略这个模块。
控制：不是网络游戏，刚体，物理引擎什么的都可以上。
表现：角色表现不区分表现逻辑和表现层，因为没必要呀。。又不是ACT游戏。。
关卡实现：大量的，细小的组件脚本来组成关卡逻辑（不是网络游戏的优势哇。。。）
时间控制：
	暂停：好说，但思考下不用Timescale，冥冥之中感觉这是一个坑。
	时间倒退：如果是坐标等非表现类倒退，好说，但如果涉及到了表现，就可能需要快照功能，目前文档这块细节需要补充。
	时间快进：倒退后，在快进，同理倒退。
线段：逻辑好实现，但这有个坑，线段在产生之后，是会影响到可能被影响到的对象的轨迹（或者逻辑内容），比如时间倒退时，在屁股后面花一个线，那么主角实际上是会被线段挡住无法后退，所以这个坑就是对时间控制的影响，这里有一些细节需要补充，比如回退时是否还记录快照？倒退被挡住后，在快进，被线段影响的对象，是如何按照快照的轨迹快进的。

剩下就是一次关卡脚本，没什么可以啰嗦的了。
嗯。为何一个09年的游戏有还要48块。。。。Orz

2016年5月10日 01:26:57
昨天想的是，表现和逻辑不区分，不过这样就又耦合了，初步想法使用interface来拆分，不过这样的话Player类就不能叫这个名字，这个类的功能是针对主角的，但中间又夹杂着表现和移动逻辑的interface，怎么看都是别扭的。
想法其实很简单，希望一个基于接口的对象类，可以操作游戏内所有对象，只是针对不同的对象，挂接不同的实现而已，但是否需要这么灵活的设定，需要再想想，就酱~~

2016年5月12日 02:15:40
昨天体检要早睡，今天玩了几个小时Braid，好吧，好难。。。前进和后腿还有进度的，表现力也很强，各种材质满天飞。。美术赞~

2016年5月14日01:39:24
移动问题解决了，旧跳跃代码存在bug，可能会跳的非常高，新的实现需要修改地图layer，现在没鼠标调整起来好麻烦，明天搞个鼠标来调。
其实我更喜欢自己算跳跃，这样跳多高，多远，多少时间都是可控制的，用物理引擎就只能发呆。。另外，2D判断是否落地的方法还有很多种，比如碰撞、距离等等。

2016年5月17日 01:12:04
跳跃和移动问题基本解决。参考unity官方的2D土豆人的实现（官方实现虽然不是最优的，但是当前版本可行的，经过验证的方法）。
1. 地面层layer为ground，堵头的位置丢一个非ground层的object就可以了。
2. checkground节点要放在角色脚下面，采用linecast会比圆形要更准确些。
3. 当人物落地问题得到解决后，跳跃问题就迎刃而解了。
4. 喝的有点多。。。不适合写代码。
明天要做：
1. 调整当前关卡的地面层。（用鼠标会快点）
2. 移动checkground的点。
3. 替换player为猪脚预设脚本。
4. 修复移动问题。
5. 修复跳跃问题。
6. 研究一下梯子（如果有时间）。
就酱~~~

2016年5月18日 00:31:18
1. 所有碰撞体尽量用box2D。
2. 估计需要增加身体碰撞，来检测是否到达边缘。
3. 镜头有问题。以后换成在Unite2016上听到的那个插件。
下一步：
1. 测试爬梯子逻辑，加入到游戏中
2. 研究一下另外一个镜头插件。
3. 完善一下客户端猪脚框架。
4. 给猪脚增加1个中心检查点，用来墙壁检测和梯子检测。
5. 复活点实现。
6. 吃收集品实现。
7. 针刺。
能搞定这些就不错了。。就酱。

2016年5月31日 00:01:21
梯子的问题告一段落，平滑上梯子和对齐都已经以注释的形式标记在代码里了。
新版的时间功能需求已出，显示开始攻关核心玩法。
时间暂停以及后退基本参考搞定。接下来一段时间需要分析和测试代码。

2016年6月2日 01:28:47
智障了，梯子到顶的问题其实很简单，结果绕在取得控件大小的问题了，忘记了这是一个2D游戏。。。Y轴就够了啊。。T喵的。
这个蛋疼的问题这个了几个小时。FK。

不过在折腾中对坐标的知识又复习了一下。
在编辑器模式下：
	1.根节点的transform中的位置XYZ，是在worldspace的坐标。
	2.子孙节点的transform的XYZ并不是worldspace坐标，而是基于父集的坐标偏移，跟父集做加法可以得到worldspace坐标。但如果层级很深，那么就要逐个计算偏移。
	3.transform的坐标并不受scale的影响。
	4.B2D中的size是并不是最终高度，需要乘以offset
在运行时：
	1.根节点的transform的XYZ,同编辑器模式一样。
	2.子孙节点得到的是worldspace的坐标，这是unity运行时计算的出来。
	3.同编辑器模式3.
	4.B2D.bounds.size是经过与offset相乘的，所以得到是最终值，不需要在计算。

2016年6月17日 00:40:55
不可画线区域的设定有个复杂的地方，就是线可以穿过各种物体，但当线与某个不可画的区域相交时，线段变红，松开鼠标后就消失。
这里几个坑。
1. 用碰撞体，虽然有相交的函数，但判断总是有问题，unity的文档写的又不是很全面（MSDN是文档是我见过最好的），有些坑需要踩了以后才知道。
2. 坐标算，测试过后发现不行，需要计算的内容太多，算完了基本就跟碰撞体相交没什么区别的。因为线段在画的过程中是可以改变角度的。在一个合法的区域开始并画线，但过程中改变坐标导致线段中间某部分与不可画区域相交，此时如果只判断鼠标当前位置，或者线段的头坐标是不准确的，需要遍历判断，那这计算量就有点大了（最主要是这个方法太暴力，太笨了）。

需要想一个优雅的方法来解决这个问题。

问题得到了解决，方法是这样的：
1. line的碰撞体默认是trigger的，这样可以解决在过程中与猪脚产生碰撞的问题。
2. 松开鼠标后，要把trigger改为false，这样猪脚就可以站立了。
3. 鼠标移动时要动态生成碰撞体。
4. 猪脚要添加不可画区域。
5. 画线开始时forbiddenzone才开始判断是否与当前线段的碰撞体相交。（减少计算量）

经过测试，已经可实现。
不过，也遇到了bug。
1. 移动中改变碰撞体的旋转出现问题，变几次后就与line的实际旋转不同了。
2. 碰撞体相交判断一直在变，因为无法在游戏点着鼠标查看碰撞体，所以初步怀疑是bug1导致的。（现在Unity出了可以查看碰撞体的插件，有空可下来用用）

今天不早了，明天解决这2个bug，外加整理一下代码。经过几轮的修改，代码已经乱七八糟惨不忍睹了。。。。


2016年6月25日 01:26:34
喝多，顺便总结一下实现。
画线：使用射线即可解决问题，而不是用碰撞，复盘一下当初的选择，因为碰撞体和碰撞体之间有各种检查的API，第一思路是就考虑用这个，而没有跳出来想想第二解决方案，实现后发现，虽然后期bug均解决，但实现并不优雅，中间参杂着各种山寨的实现（比如forbiddenzone脚本的实现，耻辱啊。。。），这是其一。
其二，开发3D游戏会大量使用碰撞体，射线相对使用较少，所以第一时间并未想起来。解决办法，多记录，把每个功能对应可实现的方向和领域再复习一下。
其三，MLGB的珠海人民医院，报告结果错误，还以为人生就此GG了呢，太尼玛影响心情了。艹！

接下来是NPC AI的问题。
第一版，打算npc使用player的逻辑，这样行走和跳跃等模块可以公用，npc的移动也是通过射线等方式来判断。
虽然实现后是可以的，但问题也随之而来。
1. 公共模块的健壮性，未来需求如果出现冲突怎么解决。使用if else只能使代码更丑。
2. 螺丝刀错误。
3. 违背低耦合强组合的设计原则。

第二版 npc和player继承自Actor，有公共方法，符合OO设计，但。。。。。真的有必要这么麻烦吗。。
第三版 npc和player相互独立，npc的移动和player的移动不使用相同实现（因为NPC会掉落，这个缝隙如果用碰撞体实现是有问题的），跳跃逻辑相同。

目前实现第三版中，前2版本代码废弃，总结一下：
第一版，想法有点天真，忽略了项目特殊性质——易变性，而且违背了设计原则。（顺便在FUCK一下珠海人民医院）
第二版，适合较大项目，这个项目用这个方法最后只能得到臃肿的代码，但符合设计原则。
第三版，较为符合项目性质，架构虽不美观，但符合基本需求。
总结：程序结构设计最重要的原则是符合项目性质，完成项目目标。这是第一原则，一切框架，设计原理等都围绕这个来服务，如果为了符合框架而扭曲项目实现，这是本末倒置的做法。

2016年6月30日 01:03:33
unity的碰撞体有个问题。就是无法知道碰撞方面。（至少我没找到）
现在的问题是，npc和玩家是移动在各种混合层里的（tag和layer），在加入了新的规范（tag和layer）后，是否对老的移动框架有影响，进而需要一些重构？
分析：
1. 目测的规范只有tag为building，layer为wall的新规则，对现在有框架影响不大。
2. 重构时间不会太短，在进度存在不确定的时候不易重构，先污染，再治理。
3. 规范还在补充，未知部分无法预估。

所以决定先不重构。

谈回方向的问题，是哟个碰撞体来检测是否撞墙是没问题的，最开始的想法人物的中心点射出一段固定长度的射线，碰到墙再转身。
不过会受到画线的影响，无法确定线段的具体位置，总不能把角色周身遍布射线吧，所以采用碰撞体是没错的。
但碰撞体没方向。也就是说我不知道npc是怎么碰到的对方。
所以，碰撞体检测只检测是是否撞墙，但跌落还是要使用射线。
跌落也是射线，不过计算脚底坐标有点问题，明天改。
